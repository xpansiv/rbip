
##
##  A recent study (https://www.nature.com/articles/s41467-021-21289-y) by 
##  McClain et al. analyzed the host response to SARS-CoV-2 infection through 
##  RNA sequencing of peripheral blood samples from subjects with COVID-19, 
##  comparing them to subjects with seasonal coronavirus, influenza, 
##  bacterial pneumonia, and healthy controls. Here, we will use the data 
##  generated by this study, publicly available at GEO under accession GSE161731
##  (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE161731), to 
##  perform a differential gene expression analysis between conditions in R.
##



## Before starting: install and load required R packages

  # Make sure you have R (https://cran.r-project.org/bin/windows/base/) (>=4.0.0) 
  # and Rstudio (https://www.rstudio.com/products/rstudio/download/#download) 
  # installed. Then install the following packages:
  
  install.packages("BiocManager")  # From CRAN
  
  BiocManager::install(version = "3.12", update = FALSE)
  
  options(timeout = 600) # Allow large package download
  
  BiocManager::install(c("edgeR", "topGO", "org.Hs.eg.db",  # From Bioconductor
                         "factoextra", "pheatmap"           # and CRAN
                         ), update = FALSE)
  
  # Load them in R:
  library(edgeR)  # edgeR loads limma 
  library(factoextra)
  library(pheatmap)
  library(topGO)
  library(org.Hs.eg.db)
  
  # And set your working directory:
  setwd("C:/Users/User/Desktop")  # Substitute 'User' by your actual username
  
  

## Download RNA-seq data from GEO and load it into R

  files_to_download <- c("GSE161731_counts.csv.gz",      # Gene expression (count matrix)
                         "GSE161731_counts_key.csv.gz")  # Metadata
  
  # Download them
  for (f in files_to_download) {
    url <- paste0("https://ftp.ncbi.nlm.nih.gov/geo/series/GSE161nnn/GSE161731/suppl/", f)
    download.file(url, destfile = f)
  }
  
  # Load both files in R
  counts <- read.csv("GSE161731_counts.csv.gz", 
                     header = TRUE, check.names = FALSE, row.names = 1)
  metadata <- read.csv("GSE161731_counts_key.csv.gz", 
                       header = TRUE, check.names = FALSE, row.names = 1)
  
  # Have a look at 'counts':
  counts[1:5, 1:5]
  dim(counts)
  
  # Have a look at 'metadata':
  head(metadata)
  dim(metadata)
  
  

## Data preprocessing
  
  # Before doing any further analysis, we should clean the data up. Among others:
  
  # Remove duplicated measurements:
  
  # Count samples per condition
  table(metadata$cohort)
  
  # Some individuals have replicated measurements
  table(table(metadata$subject_id)) 
  metadata <- metadata[!duplicated(metadata$subject_id), ] # remove them
  table(metadata$cohort)
  
  counts <- counts[, rownames(metadata)]  # Subset count matrix accordingly
    
  # Ensure that the variables are of the appropriate class:
  
  # Convert age to numeric
  class(metadata$age)
  metadata$age <- gsub(">89", "90", metadata$age)
  metadata$age <- as.numeric(as.character(metadata$age))
  class(metadata$age)
  
  # Metadata cleanup
  
  # Remove/modify some characters in the "cohort" and "race" columns
  cols <- c("cohort", "race")
  metadata[, cols] <- apply(metadata[, cols], 2, function(x){
    y <- gsub("-", "", x)   # Remove "-" 
    z <- gsub(" ", "_", y)  # Change " " (space) by "_"
    w <- gsub("/", "_", z)  # Change "/" by "_"
    return(w)
  })
  
  # Rename rows of 'metadata' (columns of 'counts') to individual id
  identical(rownames(metadata), colnames(counts))
  rownames(metadata) <- metadata$subject_id
  colnames(counts) <- metadata$subject_id
  
  # Remove some columns from 'metadata'
  metadata[, c("subject_id", "time_since_onset", "hospitalized")]  <- NULL 
  
  # Have a look (again) at 'counts':
  counts[1:5, 1:5]
  dim(counts)
  
  # Have a look (again) at 'metadata':
  head(metadata)
  dim(metadata)
  
  # Subset the conditions of interest. As an example, here we will use the 
  # 'Bacterial' and 'Influenza' groups.
  metadata <- subset(metadata, cohort %in% c("Bacterial", "Influenza"))
  counts <- counts[, rownames(metadata)]
  
  
  
## Gene expression normalization and removal of lowly expressed genes
  
  # Prior to differential gene expression analysis, the count matrix should be 
  # normalized to take into account the library size (e.g. in an experiment A 
  # with a high number of mapped reads, a gene will get more reads than in an 
  # experiment B with a smaller number of mapped reads). 
  # Lowly expressed genes should also be removed.  
  
  dge <- DGEList(counts)  # Create DGEList object
  class(dge)
  
  dge$counts[1:5, 1:5]
  head(dge$samples)
  
  # CPM (Counts Per Million Reads) - corrects for library size
  CPM <- cpm(dge)
  class(CPM)
  CPM[1:5, 1:5]
  
  # Remove lowly expressed genes (e.g median CPM < 0.2)
  drop <- which(apply(CPM, 1, median) < 0.2)
  dge <- dge[-drop, ]
  CPM <- CPM[-drop, ]
  dim(CPM)  # Number of genes left = dim(dge)

    
  
## Exploratory data analysis
  
  # Principal Component Analysis (PCA)
  PCA <- prcomp(t(CPM), scale = T)
  fviz_pca_ind(PCA, 
               habillage = metadata$cohort, 
               # try others e.g. metadata$race, metadata$gender
               # for numerical variables e.g. 'age', use instead: col.ind = metadata$age
               pointsize = 3) 
  
  # Clustering/Heatmap
  pheatmap(log2(CPM + 1),
           show_rownames = F, 
           annotation_col = metadata)
  
  # Remove outlier individuals (`896282`). Recompute 'metadata', 'counts', 'dge' and 'CPM':
  metadata <- metadata[-which(rownames(metadata) == "896282"), ] 
  counts <- counts[, -which(colnames(counts) == "896282")]
  dge <- DGEList(counts)
  CPM <- cpm(dge)
  drop <- which(apply(CPM, 1, median) < 0.2)
  dge <- dge[-drop, ]
  CPM <- CPM[-drop, ]
  


## Differential gene expression analysis (voom + limma)
  
  # Specify model (include age to correct)
  age <- metadata$age
  cohort <- metadata$cohort
  
  mm <- model.matrix(~0 + age + cohort)
  
  # Learn voom weigths
  y <- voom(dge, mm, plot = T)
  
   # What is voom doing? (more details here: 
   # https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-2-r29)
   # - Counts are transformed to log2(CPM)
   # - A linear model is fitted to the log2(CPM) for each gene, and the residuals
   #   are calculated.
   # - A smoothed curve is fitted to the sqrt(residual standard deviation) by 
   #   average expression (see red line in plot above).
   # - The smoothed curve is used to obtain weights for each gene and sample that 
   #   are passed into limma along with the log2(CPM).
  
  # Now `limma` fits a linear model using weighted least squares for each gene:
  fit <- lmFit(y, mm)
  
  # Comparisons between groups (log fold-changes) are obtained as contrasts of 
  # these fitted linear models
  contr <- makeContrasts(cohortBacterial - cohortInfluenza, levels = colnames(coef(fit)))
  
  # Estimate contrast for each gene
  tmp <- contrasts.fit(fit, contr)
  
  # Empirical Bayes smoothing of standard errors 
  # (shrinks standard errors that are much larger or smaller than those 
  # from other genes towards the average standard error,
  # see https://www.degruyter.com/doi/10.2202/1544-6115.1027)
  tmp <- eBayes(tmp)
  
  results <- topTable(tmp, sort.by = "P", n = Inf) # Get all results, ordered by P-value
  
  # Have a look at 'results':
  head(results)
  dim(results)
  
   # - logFC: log2 fold change of Bacterial/Influenza
   #    logFC is positive: a gene has higher expression in 'Bacterial' than in 'Influenza'.
   #    logFC is negative: has lower expression in 'Bacterial' than in 'Influenza'. 
   # - AveExpr: Average expression across all samples, in log2(CPM)
   # - t: logFC divided by its standard error
   # - P.Value: Raw p-value (based on t) from test that logFC differs from 0
   # - adj.P.Val: Benjamini-Hochberg false discovery rate (multiple testing correction, FDR) adjusted p-value
   # - B: log-odds that gene is DE (less useful than the other columns)
  
  # Volcano plot:
  ggplot(results, aes(x = logFC, -log10(adj.P.Val))) + 
    geom_point() 
  
  # How many DE genes are there? (5% FDR)
  results.sig5 <- subset(results, adj.P.Val < 0.05) 
  dim(results.sig5)
  
  # Volcano plot (coloring top genes):
  results$sel <- (results$adj.P.Val < 0.05 & abs(results$logFC) > 5)
  ggplot(results, aes(x = logFC, -log10(adj.P.Val), color = sel)) + 
    geom_point() 
  
  # Boxplots for the top 1 gene:
  df <- data.frame(metadata, expression = log2(CPM[rownames(results.sig5)[1], ] +1 ))
  ggplot(df, aes(x = cohort, y = expression, fill = cohort)) +
    geom_boxplot() +
    ylab("log2(CPM+1)") +
    ggtitle("Top 1 gene expression vs 'cohort'") +
    theme(plot.title = element_text(hjust = 0.5))
  
  # Heatmap/clustering (only DE genes):
  pheatmap(log2(CPM[rownames(results.sig5), ] + 1 ), 
           show_rownames = F, 
           annotation_col = metadata[, "cohort", drop = F])
  
  # You can find out more about the differentially expressed genes and their 
  # protein products (if any) at GeneCards (https://www.genecards.org), 
  # Ensembl(http://www.ensembl.org/index.html), Uniprot (https://www.uniprot.org) 
  # or Pubmed (https://pubmed.ncbi.nlm.nih.gov).
  
  

## Gene Ontology enrichment analysis
  
  # topGO requires all genes as a named list of P-values, plus a function to 
  # select significant genes
  allGenes <- results$adj.P.Val
  names(allGenes) <- rownames(results)
  
  # Create topGO object
  GOdata <- new("topGOdata",
                ontology = "BP",
                allGenes = allGenes,
                geneSel = function(p){p < 0.05}, # Define function
                annotationFun = annFUN.org,
                mapping = "org.Hs.eg.db",
                ID = "ensembl")
  
  resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  
  # Results
  GOres <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 10)
  
  # Have a look at 'GOres':
  head(GOres)
  
  # You can learn more about Gene Ontology here: http://geneontology.org.
  